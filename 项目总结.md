
# 项目总结

## 整体流程介绍

用户输入账号密码验证成功后进入系统，然后选择相应的科目，拿到题目列表，并选择某一道题目打开进入做题页，做题页可以打开多道题目，同时有未通过数据的实时展示，可以进行代码的编写，保存，编译，运行和断点调试，断点调试开启后会新增三个面板来展示调试信息，分别是变量堆栈面板，变量监视面板和数据结构可视化面板，数据结构可视化不是我负责，其他的两块是我负责。

### 变量堆栈
#### 需求部分
    每次进入一个函数栈都会在变量堆栈面板显示其内容，包括函数名，和函数里面的变量，这里是用树形展示的，因为可能会有复杂变量，然后还有就是，每次点击调试之后我都要对上一次调试的堆栈树做状态保存，因为需要与下一次的调试堆栈数据做对比，需要做的事情有下面几条
    0.使用watch监听对象里堆栈相关的信息
    1.我需要将本次发生变化的变量做高亮，以便用户知道本次调试哪个数据发生了变化
    2.我需要以动画的形式来提醒用户当前变化的变量所属的结点，因为变化的值可能是某个对象的某个属性。这个地方的话是采用一个递归冒泡的形式来完成的，就是找到变化的变量后，向其父级元素冒泡查询，看该元素是否在用户的视野内，即判断其父级元素是否为展开状态，找到后就让父级元素闪一下提醒用户。
    3.发生函数入栈出栈时要产生相应的入栈出栈动画。
    4.将后端传过来的字符串做解析高亮。
    5.每个变量hover的时候都会有小弹层显示该变量上一次的值，这个在对比树的时候就存下来了。
    7.做函数和变量的高亮显示（比如指针类型的变量和普通类型的变量颜色不同）。
#### 实现部分
	在原来做这块的时候，我是用一个tree组件直接渲染所有的栈数据然后再通过循环递归的方式对所有的函数栈做逻辑处理，找出变化的函数栈并做动画处理，所以每次数据改变时，都需要完整的遍历一次整个栈数组，后来我发现每次点击调试相关按钮影响的栈其实只有可能是最上面的两个函数栈，即栈顶函数和栈顶函数的下一个函数，因为点击调试后主要有三种情况的出现，一种是有新函数入栈，这个时候只需要把当前栈顶元素向下移动变为非函数栈，同时新增一个函数向下移动作为最新的栈顶函数，这里涉及到的变化只有栈顶函数，再看另一种情况，就是有函数出栈，这个时候的处理只是将栈顶函数向上移除，并将下一个元素移动上来作为栈顶，这里只涉及到栈顶元素和他的下一个元素的变化，还有一种情况就是没有函数出栈入栈，这也是最常见的情况，就是只涉及到函数内部变量的变化，这种只需要递归+遍历栈顶函数内部的变量，并与之前缓存的旧函数栈做diff对比即可得到变化的元素。
	所以整个看下来，其实变化的始终只是栈顶函数和他的下一个函数，而再往后的函数就只是一个展示的功能了，他们只负责每次数据更新时重新渲染即可，不必遍历他们的内部。所以考虑到这一点，和代码的解耦性，我决定将组件拆为三个部分，一个就是栈顶函数，另一个就是非栈顶函数中最顶部的函数，即栈顶函数的下一个函数，还有一部分就是剩下的其他函数。这三个分别写在了三个组件里面，再由一个父级组件来对他们做数据的总控制，在父组件里面会对vuex中调试相关的对象数据做深度监听，使用watch中的deep嘛，只要监听到调试数据发生了变化，那么就会拿到最新的堆栈变量数据，和上次调试缓存的旧堆栈数据作对比，首先就是先比较数组长度上是否发生了变化，变成还是变短，这就决定了函数是出栈还是入栈，或者是长度没有变化，判断完成后就会根据实际情况做组件数据的更新，比如有新函数入栈，那么肯定是将活动函数换下来，换成新入栈的函数，而原来的活动函数就会变成非活动函数的栈顶，也就是会作为刚才提到的一个组件之一，当然这两个组件发生变化之前都会先做一下动画，剩下的数据自然就是作为只是负责展示的组件的数据。这样 子设计其实不管从代码层面还是逻辑层面都会很清晰，首先就是动画操作和数据逻辑操作是解耦的比较开的，另一方面就是避免了重复遍历一些没必要的数据，提高了性能。

#### 虚拟滚动条
##### 实现原因
	首先说一下我为什么要做这块内容，因为我发现当Coding页面开启调试的时候，页面上同时存在六七个面板，然后每一个面板都是可滚动的，这意味着他们可能会同时拥有滚动条，而原生滚动条是比较站空间且不美观的，特别是在小屏幕电脑上这种感觉更强烈，所以我就去网上找一些解决方案，然后发现element-UI里面就隐藏着这样的一个组件，他的官网滚动条就是这个实现的，所以我就直接套用了，然后发现了一个问题，就是当容器里面的内容高度发生变化时滚动条可以正常运行，但是当容器的高度发生变化时，我发现滚动条不会响应，就是不能向下滚动，我以为是element的bug，所以去issue里面找了下相关问题的答案，然后也没有我想要的回答，就只是有开发者回复说这个虚拟滚动条是为他们内部组件使用的，没有对外开放，所以功能设计方面考虑的不是太周全，所以我就意识到了这个问题可能不是bug，可能是他压根没有实现容器resize这个功能。于是我去找他的源码看了一下，发现确实是这样。
##### api设计
	然后我又没办法修改element的组件源码，所以就决定自己着手开发一个这样的功能。首先这是一个通用组件，所以我们应该设计它的使用方式和API，使用方式的话其实就是一个容器标签scrollbar，然后容器里面放置我们需要展示的内容，API无非就是三个方面，prop，event和slot。slot的话不用说，肯定就是用户要放入容器里面的内容，然后prop的话其实就是滚动条的样式设置，还有容器的标签以什么形式渲染，为了简单起见我只弄了这两个prop，已经够用了。再说下event部分，这里的话我弄了滚动事件的监听，因为用户可能需要做些操作。
##### 外部和内部的dom结构设计
	然后做完api的设计接下来就是考虑组件的内部结构了，对外只有一个容器标签，用户以slot的形式放入自己的内容。但是组件内部的结构其实是分为比较多块的，最外层是一个隐藏容器，他的主要作用其实是为了用来隐藏真正容器的滚动条，所以我们要将他设置为overflow:hidden， 然后真正的容器我们设置为overflow:scroll ，这样我们就可以使用浏览器原生的滚动效果了，就是鼠标滚动的时候内容可以向下滑。因为滚动条的大小在不同地方有可能不一致，所以这里可以通过创建一个div来利用offsetWidth和clientWidth来相减计算出滚动条的宽度再把他们删除，真正容器我们叫他wrap，wrap里面是一个view，view里面就放置用户传来的slot，然后和wrap并列的就是我们做的虚拟滚动条了。虚拟滚动条那里也包含两层的DOM，就是滚动条容器和滚动块两部分。
##### 具体逻辑
	刚才说的就是html部分的结构，然后说一下文件，其实文件主要就两个，一个是总的逻辑处理文件，一个就是滚动条相关的文件。接下来说一下主要的实现逻辑，首先要实现的事件主要有滚动内容块时滚动条也跟着动，拖动滚动条或者点击滚动轨道的时候内容也可以跟着滚动，然后这些的核心思想其实就是利用包含块和内容块，滚动轨道和滚动条的相似性，来实现滚动内容和滚动条的联动。因为内容块和包含块的比值就等于滚动块和滚动条的比值嘛，所以后面我们实现的几个事件都是基于这个思想来的，比如滚动内容触发滚动条的位置变化，拖动滚动块或者点击滚动轨道触发内容块的滚动，或者是窗口或内容的长度发生变化导致滚动条长度的变更，这些都是通过相似性来实现的，所以这块我把相似性这个逻辑做了一下封装，就是可以根据传入的参数计算你想要的值，比如现在包含块的高度调整了，那么我就可以通过这个计算函数轻松计算出滚动条当前的长度，然后再通过prop传给滚动组件即可实现滚动条高度的实时调整。然后关于位移的计算还用了个小小的原理，就是当内容块滚动的距离刚好等于包含块的高度的时候，滚动块的translate的值刚好是100%，利用这个我们就可以通过百分比的方式来方便的计算位移了。
##### 杂谈
	这个就是大致的实现了，剩下的就是一些利用getBoudingRect，scrollTop获取属性，然后计算结果再通过改变translate改变视图之类的操作，本来还打算用防抖来优化一下resize事件，后来想到滚动条的长度需要实时改变就取消掉了。
##### 我的优化和element的优缺点
	element关于这块的的实现缺点：
	1.首先就是没有实现我那个包含块resize的需求
	2.就是它的计算逻辑比较松散，每个地方都会写一套计算，有些地方逻辑是重复的，而我将计算逻辑做了一下封装，更能体现这块的核心思想，用起来也方便些。
	优点：代码啥的组织的很好，印象比较深刻的一点就是用了两个对象来管理横向滚动条和竖向滚动条的一些属性，这样使用起来的时候看起来就很清晰，所以比较值得借鉴。








